# Objective #

  * Extend Firefox to persist its configuration and state on a central server.
  * Allow users to access this state from any Firefox instance on any trusted machine.

## Non-Goals ##

Clobber is not being designed with the intent to allow simultaneous sessions from multiple Firefox instances. A user may only be logged into one Clobber session at a time. Upon starting a new session, any existing sessions will be closed.

Clobber is not recommended for use on untrusted, single-use machines, such as in coffeeshops or internet cafes. There will be no mechanism for Clobber to remove any downloaded browser state after a session is complete.


# Overview #

Clobber achieves browser state synchronization using a client-server model with communication over HTTP. This document describes the system as a whole, treating the two major components as black boxes, and focusing on client-server interaction. For an in-depth discussion of the client internals, refer to ClientDesign.

Users will have the option to sync any or all of the following pieces of standard Firefox state:

  * Bookmarks
  * Passwords
  * Tabs/windows
  * Cookies
  * History
  * Preferences

# Detailed Design #

## Authentication ##

Clobber's authentication process involves verifying the identity of both the user and the client, to try to protect the user's data even in the event that his login information is stolen.

### User Authentication ###

Clobber uses Google Accounts to authenticate users, as this provides several benefits:

  * Users don't have to remember new login information for regular use of Clobber
  * A programmatic authentication API already exists

The primary drawback of using Google Accounts is the increased risk of user login info being stolen through phishing attacks or other security breaches. This login info is only as secure as the least secure Google Accounts-enabled service. To help offset this increased risk, Clobber also verifies the validity of the machine issuing the request, before transferring the user's stored data.

The Clobber client communicates with Google Accounts directly via the [programmatic login API](http://code.google.com/apis/accounts/docs/AuthForInstalledApps.html) to acquire an SID cookie prior to beginning a Clobber session. This SID cookie must be passed to the server with every request in the form of the sid query parameter, for the duration of the Clobber session.

### Client Authentication ###

Every request that stores state, retrieves state, or modifies the user's account must include client credentials in addition to the SID cookie. The two required pieces of information are the current _client id_, passed as the `mid` query parameter, and the user's _state-encryption key_, encrypted with the user's unique _client-authorization token_, passed as the `key` parameter.

#### Client Id ####

The client id is a 40-byte random string generated by the client upon installation of the Clobber extension (see ClientDesign for details). Whenever a Clobber session is started, the server stores the id of the client opening the session, and for the duration of the session, any requests sent with a different client id will be rejected, even if the user authentication passes. If the user begins a session from a different client by calling `/start_session` or `/add_client` (see "Request Types" below), the server will recognize the second client id as being the current active client, and all incoming requests from the first client will be rejected (with client-side UI to indicate that the user has been logged out).

#### Encryption Key ####

The second piece of client authentication data, the token-encrypted encryption key, is used to prove that the client knows the user's encryption secret and should be allowed to receive or modify his browser state. The 40-byte encryption key is generated at the time of Clobber account creation, and is used by a symmetric-key algorithm to encrypt and decrypt any data that the user wishes to protect (see ClientDesign for details). This key is stored in raw form on the client, and then encrypted with the client-authorization token (see below) and sent to the server for storage in the user's Clobber profile. The `key` value sent in a request must match this value stored in the profile, or else the client authentication will fail.

The server does not store the raw encryption key so that 1) Google does not have a way to decrypt users' encrypted data, and 2) the raw key is never exposed in communication between the client and server, where it could be observed by a third party. When the user wishes to use a new client for the first time, and needs to obtain the encryption key from the server, he will need to enter the client-authorization token.

#### Client-Authorization Token ####

The client-authorization token is a random string, generated by the client at account creation, that the user will have to provide whenever he wants to authorize a new client to access his stored browser state. This token is stored locally in raw form, and can be retrieved later from any authorized client. When the token is first generated, the client performs a one-way hash of the token and sends the result to the server for storage in the user's Clobber profile. When the user tries to use a new client with his account for the first time, he will have to enter this token, which will be hashed and sent to the server as the `token` parameter of an `/add_client` request. If the value matches the one in the user's profile, the server will return token-encrypted encryption key, which the client will decrypt using the token that the user entered in the previous step. Once the key has been decrypted, the client will be considered an authorized client.

The server does not store the raw client-authorization token because it can be used to decrypt the user's encryption key, which is bad for the reasons stated above.

## Request Types ##

There are currently seven request types that the client may issue to the server, which perform the general tasks of account, session, and browser state management.

The common query parameters are:

  * `sid` - SID cookie from Google Accounts
  * `mid` - unique string identifying this client (machine id)
  * `key` - encryption key, encrypted with client-authorization token
  * `token` - client-authorization token, passed through one-way hash

On any request, in addition to the valid responses listed below, the server may return a `500 Server Error` response in the event of an unrecoverable error, such as the storage backend being unreachable, or a `400 Bad Request` if required query parameters were missing.

### Account Management ###

#### /create\_user ####

**Purpose:**
To create a new Clobber account and initialize Clobber profile data

**Request:**
`POST /create_user?sid=SID&mid=MID&key=KEY&token=TOKEN`

**Response:**
  * `200 OK`
  * `403 Forbidden` - Invalid sid
  * `409 Conflict` - Clobber profile already exists for given user

#### /add\_client ####

**Purpose:**
To make a new client "authorized" and obtain the encryption key

**Request:**
`POST /add_client?sid=SID&mid=MID&token=TOKEN`

**Response:**
  * `200 OK` - body includes token-encrypted state-encryption key
  * `403 Forbidden` - Invalid sid or token

#### /verify\_user\_exists ####

**Purpose:**
Check whether a Clobber profile exists for the given user

**Request:**
`GET /verify_user_exists?sid=SID`

**Response:**
  * `200 OK`
  * `403 Forbidden` - User does not exist

### Session Management ###

#### /start\_session ####

**Purpose:**
To begin a new Clobber session, making this client the current active client

**Request:**
`POST /start_session?sid=SID&mid=MID&key=KEY`

**Response:**
  * `200 OK`
  * `403 Forbidden` - Invalid `sid` or `key`

#### /end\_session ####

**Purpose:**
To end the current Clobber session, clearing the current active client

**Request:**
`POST /end_session?sid=SID&mid=MID&key=KEY`

**Response:**
  * `200 OK`
  * `403 Forbidden` - Invalid `sid`, `mid`, or `key`

### Browser State Management ###

#### /sync ####

_TODO: I think there may be some errors in this section. The source was out of date and I tried to fill it in by memory._

**Purpose:**
To upload new browser state

**Request:**
`POST /update?sid=SID&mid=MID&key=KEY&timestamp=TIMESTAMP`

**Response:**
  * `200 OK` - body includes `lastUpdate` timestamp assigned to this state and requested browser state (see Data Format, below)
  * `400 Bad Request` - Invalid XML
  * `403 Forbidden` - Invalid `sid`, `mid`, or `key`

## Data Format ##

The client and server represent browser state internally in different formats, so a common format must be used in any client-server communication. The same format is used for both pushing data up to the server and pulling it down to the client. The only difference is that the data sent from the server to the client will also include a 

&lt;lastUpdate&gt;

 field, indicating the server timestamp (in ISO 8601 format) to which the included data is current. The client should use this timestamp to indicate its last known synced state when requesting future syncs from the server.

### Add ###

Add a new item to the stored browser state by specifying any appropriate identifying information (`componentID` and `itemID` are required, `typeID` only applies to some components) and the initial field values. Any fields that are missing from the Add item are assumed to be undefined.

```
<sync
 xmlns="http://google.com/browserstate"
 xmlns:xs="http://www.w3.org/2001/XMLSchema"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 // lastUpdate only included for server->client communication
 <lastUpdate>2005-11-24T01:29:34Z</lastUpdate>
 <item>
   <componentID>@google.com/browserstate/bookmark;1</componentID>
   <itemID>rdf:#$o8SHG2</itemID>
   <typeID>folder</typeID>
   <prop name="title" xsi:type="xs:string">foo</prop>
   <prop name="description" xsi:type="xs:string">my new folder</prop>
   ...
 </item>
</sync>
```

### Update ###

The format for an Update item is the same as an Add item. The entry need only contain enough information to uniquely identify the item, and the new values of any fields that are being updated. This sample shows setting the "title" field to a new value, and deleting the "description" field by setting the `xsi:nil` attribute to "true".

```
<sync
 xmlns="http://google.com/browserstate"
 xmlns:xs="http://www.w3.org/2001/XMLSchema"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 <item>
   <componentID>@google.com/browserstate/bookmark;1</componentID>
   <itemID>rdf:#$o8SHG2</itemID>
   <typeID>folder</typeID>
   <prop name="title" xsi:type="xs:string">bar</prop>
   <prop name="description" xsi:nil="true"/>
 </item>
</sync>
```

### Delete ###

Item deletion is indicated by the `isRemove` element. If the `isRemove` element is present, any other field updates in this item will be ignored.

```
<sync
 xmlns="http://google.com/browserstate"
 xmlns:xs="http://www.w3.org/2001/XMLSchema"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 <item>
   <componentID>@google.com/browserstate/bookmark;1</componentID>
   <itemID>rdf:#$o8SHG2</itemID>
   <typeID>folder</typeID>
   <isRemove/>
 </item>
</sync>
```